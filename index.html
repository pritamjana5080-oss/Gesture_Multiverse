<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gesture Particles - Stable Universe</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000000; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        #video-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            border: 1px solid #333;
            border-radius: 4px;
            overflow: hidden;
            z-index: 10;
            opacity: 0.6;
            transform: scaleX(-1);
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; }
        #ui {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: white;
            pointer-events: none;
            z-index: 20;
        }
        h1 { margin: 0; font-size: 1.5rem; text-shadow: 0 0 10px #00ffcc; color: #fff; }
        .hud-box {
            margin-top: 10px;
            background: rgba(10, 10, 10, 0.7);
            padding: 15px;
            border-left: 4px solid #00ffcc;
            width: 320px;
        }
        #active-gesture { font-size: 1.2rem; color: #00ffcc; font-weight: bold; text-transform: uppercase; }
        .legend { margin-top:10px; opacity:0.8; font-size: 0.8rem; line-height: 1.6em; color: #ddd; }

        #watermark {
            position: absolute;
            bottom: 15px;
            right: 20px;
            color: #00ffcc;
            opacity: 0.5;
            font-size: 0.9rem;
            pointer-events: none;
            z-index: 30;
            text-shadow: 0 0 2px rgba(0,0,0,0.8);
            letter-spacing: 1px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <div id="video-container"><video id="input_video" playsinline></video></div>

    <div id="ui">
        <h1>PARTICLE ENGINE</h1>
        <div class="hud-box">
            <div>STATUS: <span id="active-gesture">UNIVERSE MODE</span></div>
            <div id="debug-fingers" style="color:#666; font-size:10px; margin-top:5px;">Show Hand to Control</div>
        </div>
        <div class="legend">
            ‚úä 0: PRITIKA<br>
            ‚òùÔ∏è 1: YOUR SMILE<br>
            ‚úåÔ∏è 2: IS TOO<br>
            ü§ü 3: PRECIOUS<br>
            üññ 4: ALWAYS<br>
            üñê 5: KEEP IT
        </div>
    </div>

    <div id="watermark">·¥Ö·¥á·¥†‚àû·¥ò Ä…™·¥õ·¥Ä·¥ç</div>

<script>
    // --- SETTINGS ---
    const CONFIG = {
        particleCount: 16000, 
        particleSize: 0.16,
        morphSpeed: 0.08, // Increased for snappier text formation
    };

    // --- THREE.JS INIT ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.015);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 40;

    const renderer = new THREE.WebGLRenderer({ antialias: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // --- PARTICLE SYSTEM ---
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(CONFIG.particleCount * 3);
    const targets = new Float32Array(CONFIG.particleCount * 3);
    const colors = new Float32Array(CONFIG.particleCount * 3);

    // Initial Universe
    for (let i = 0; i < CONFIG.particleCount * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 200;
        targets[i] = positions[i];
        colors[i] = 1;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: CONFIG.particleSize,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.9,
    });

    const particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);

    // --- TEXT GENERATION ENGINE ---
    let currentTextPoints = [];

    function generateTextPoints(text) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 350; 
        canvas.height = 80;
        
        ctx.fillStyle = 'black';
        ctx.fillRect(0,0,350,80);
        
        ctx.fillStyle = 'white';
        const fontSize = text.length > 8 ? 35 : 45;
        ctx.font = `bold ${fontSize}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, 175, 40);

        const imageData = ctx.getImageData(0, 0, 350, 80);
        const data = imageData.data;
        const points = [];

        for(let y=0; y<80; y+=1) { 
            for(let x=0; x<350; x+=1) {
                const alpha = data[(y*350 + x)*4];
                if(alpha > 128) {
                    points.push({
                        x: (x - 175) * 0.22, 
                        y: (40 - y) * 0.22,
                        z: 0
                    });
                }
            }
        }
        return points;
    }
    
    function getTextTarget(index) {
        if (currentTextPoints.length === 0) return {x:0, y:0, z:0};
        const p = currentTextPoints[index % currentTextPoints.length];
        return {
            x: p.x + (Math.random()-0.5)*0.15,
            y: p.y + (Math.random()-0.5)*0.15,
            z: p.z + (Math.random()-0.5)*0.5 
        };
    }

    // --- LOGIC ---
    let currentShape = "";
    let targetHandPos = new THREE.Vector3(0, 0, 0);
    let currentHandPos = new THREE.Vector3(0, 0, 0);

    function setShape(text, colorType) {
        if(currentShape === text) return;
        currentShape = text;
        
        const el = document.getElementById('active-gesture');
        el.innerText = text;
        
        // --- MODE: UNIVERSE ---
        if (text === "UNIVERSE") {
            el.style.color = "#ffffff";
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                targets[i3] = (Math.random() - 0.5) * 200;
                targets[i3+1] = (Math.random() - 0.5) * 150;
                targets[i3+2] = (Math.random() - 0.5) * 100;
                
                const r = Math.random();
                if(r > 0.9) { colors[i3]=1; colors[i3+1]=0.8; colors[i3+2]=0.5; }
                else if(r > 0.7) { colors[i3]=0.6; colors[i3+1]=0.8; colors[i3+2]=1; }
                else { colors[i3]=0.8; colors[i3+1]=0.8; colors[i3+2]=0.8; }
            }
            geometry.attributes.color.needsUpdate = true;
            return;
        }

        // --- MODE: TEXT ---
        currentTextPoints = generateTextPoints(text);

        let colorFunc;
        switch(colorType) {
            case 0: colorFunc = () => new THREE.Color(1.0, 0.2, 0.6); el.style.color = "#ff3399"; break;
            case 1: colorFunc = () => new THREE.Color(1.0, 0.9, 0.2); el.style.color = "#ffcc00"; break;
            case 2: colorFunc = () => new THREE.Color(0.2, 1.0, 0.5); el.style.color = "#33ff88"; break;
            case 3: colorFunc = () => new THREE.Color(0.2, 0.8, 1.0); el.style.color = "#33ccff"; break;
            case 4: colorFunc = () => new THREE.Color(0.8, 0.4, 1.0); el.style.color = "#cc66ff"; break;
            case 5: colorFunc = () => new THREE.Color(1.0, 0.5, 0.2); el.style.color = "#ff8833"; break;
            default: colorFunc = () => new THREE.Color(1,1,1);
        }

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const i3 = i * 3;
            // No need to update targets here yet, we do it in animate loop relative to hand
            // Just update colors
            const c = colorFunc();
            const variance = (Math.random() - 0.5) * 0.3;
            colors[i3] = Math.max(0, Math.min(1, c.r + variance));
            colors[i3+1] = Math.max(0, Math.min(1, c.g + variance));
            colors[i3+2] = Math.max(0, Math.min(1, c.b + variance));
        }
        geometry.attributes.color.needsUpdate = true;
    }

    // --- HAND TRACKING & STABILIZER ---
    function dist(p1, p2) {
        return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
    }

    let gestureBuffer = [];
    const BUFFER_SIZE = 5; // Low latency buffer
    let handLostFrames = 0; // To prevent flicker
    const LOSS_THRESHOLD = 40; // ~1 second grace period before going back to Universe

    function onResults(results) {
        const debugEl = document.getElementById('debug-fingers');

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            // HAND DETECTED
            handLostFrames = 0; 
            const lm = results.multiHandLandmarks[0];
            
            // Map position
            const rawX = (0.5 - lm[9].x) * 50; 
            const rawY = (0.5 - lm[9].y) * 35;
            targetHandPos.set(rawX, rawY, 0);

            // Gesture Logic
            const wrist = lm[0];
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18];
            
            let fingers = 0;
            // Thumb
            if(dist(lm[4], lm[17]) > dist(lm[3], lm[17])) fingers++;
            // Fingers
            let otherFingers = 0;
            for(let i=0; i<4; i++) {
                if(dist(lm[tips[i]], wrist) > dist(lm[pips[i]], wrist)) otherFingers++;
            }
            fingers += otherFingers;

            // Wide hand 5-finger fix
            if (otherFingers === 4 && dist(lm[4], lm[20]) > dist(lm[0], lm[9]) * 1.5) fingers = 5;

            debugEl.innerText = `Fingers: ${fingers}`;

            gestureBuffer.push(fingers);
            if (gestureBuffer.length > BUFFER_SIZE) gestureBuffer.shift();
            
            const counts = {};
            gestureBuffer.forEach(x => { counts[x] = (counts[x] || 0) + 1; });
            const stableGesture = parseInt(Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b));

            // Trigger Text
            if(stableGesture === 0) setShape("PRITIKA", 0);
            else if(stableGesture === 1) setShape("YOUR SMILE", 1);
            else if(stableGesture === 2) setShape("IS TOO", 2);
            else if(stableGesture === 3) setShape("PRECIOUS", 3);
            else if(stableGesture === 4) setShape("ALWAYS", 4);
            else if(stableGesture === 5) setShape("KEEP IT", 5);

        } else {
            // NO HAND DETECTED
            handLostFrames++;
            if(handLostFrames > LOSS_THRESHOLD) {
                // Only go to Universe after grace period expires
                if(currentShape !== "UNIVERSE") {
                    setShape("UNIVERSE", -1);
                }
                debugEl.innerText = "No Hand Detected";
            } else {
                debugEl.innerText = "Holding..."; // Grace period active
            }
        }
    }

    const videoElement = document.getElementById('input_video');
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });
    cameraUtils.start();

    // --- ANIMATION ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();

        // Smoothly move center
        currentHandPos.lerp(targetHandPos, 0.1);

        const pAttr = geometry.attributes.position;
        
        // Determine current morph speed
        // Fast snap to text (0.08), slow drift to universe (0.02)
        const speed = currentShape === "UNIVERSE" ? 0.02 : 0.08;

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const i3 = i * 3;
            const px = pAttr.array[i3];
            const py = pAttr.array[i3+1];
            const pz = pAttr.array[i3+2];

            let tx, ty, tz;

            if (currentShape === "UNIVERSE") {
                // Use stored random targets
                tx = targets[i3];
                ty = targets[i3+1];
                tz = targets[i3+2];
            } else {
                // Calculate text target + Hand Offset on the fly
                // This prevents text from getting "stuck" if hand moves
                const p = getTextTarget(i); 
                tx = p.x + currentHandPos.x;
                ty = p.y + currentHandPos.y;
                tz = p.z + currentHandPos.z;
            }

            let vx = (tx - px) * speed;
            let vy = (ty - py) * speed;
            let vz = (tz - pz) * speed;

            // Alive Motion
            if (currentShape === "UNIVERSE") {
                vx += Math.sin(time * 0.5 + py * 0.05) * 0.02;
                vy += Math.cos(time * 0.3 + px * 0.05) * 0.02;
            } else {
                vx += Math.sin(time * 3 + py * 0.5) * 0.005;
                vy += Math.cos(time * 2 + px * 0.5) * 0.005;
            }

            pAttr.array[i3] += vx;
            pAttr.array[i3+1] += vy;
            pAttr.array[i3+2] += vz;
        }
        pAttr.needsUpdate = true;

        if(currentShape === "UNIVERSE") {
             particleSystem.rotation.y += 0.0005;
        } else {
             // Reset rotation so text is readable
             particleSystem.rotation.y = THREE.MathUtils.lerp(particleSystem.rotation.y, 0, 0.1);
        }
        
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    setShape("UNIVERSE", -1);
    animate();
</script>
</body>
</html>
